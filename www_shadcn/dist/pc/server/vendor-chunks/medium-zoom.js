"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/medium-zoom";
exports.ids = ["vendor-chunks/medium-zoom"];
exports.modules = {

/***/ "(ssr)/./node_modules/medium-zoom/dist/medium-zoom.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/medium-zoom/dist/medium-zoom.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*! medium-zoom 1.1.0 | MIT License | https://github.com/francoischalifour/medium-zoom */\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar isSupported = function isSupported(node) {\n  return node.tagName === 'IMG';\n};\n\n/* eslint-disable-next-line no-prototype-builtins */\nvar isNodeList = function isNodeList(selector) {\n  return NodeList.prototype.isPrototypeOf(selector);\n};\n\nvar isNode = function isNode(selector) {\n  return selector && selector.nodeType === 1;\n};\n\nvar isSvg = function isSvg(image) {\n  var source = image.currentSrc || image.src;\n  return source.substr(-4).toLowerCase() === '.svg';\n};\n\nvar getImagesFromSelector = function getImagesFromSelector(selector) {\n  try {\n    if (Array.isArray(selector)) {\n      return selector.filter(isSupported);\n    }\n\n    if (isNodeList(selector)) {\n      // Do not use spread operator or Array.from() for IE support\n      return [].slice.call(selector).filter(isSupported);\n    }\n\n    if (isNode(selector)) {\n      return [selector].filter(isSupported);\n    }\n\n    if (typeof selector === 'string') {\n      // Do not use spread operator or Array.from() for IE support\n      return [].slice.call(document.querySelectorAll(selector)).filter(isSupported);\n    }\n\n    return [];\n  } catch (err) {\n    throw new TypeError('The provided selector is invalid.\\n' + 'Expects a CSS selector, a Node element, a NodeList or an array.\\n' + 'See: https://github.com/francoischalifour/medium-zoom');\n  }\n};\n\nvar createOverlay = function createOverlay(background) {\n  var overlay = document.createElement('div');\n  overlay.classList.add('medium-zoom-overlay');\n  overlay.style.background = background;\n\n  return overlay;\n};\n\nvar cloneTarget = function cloneTarget(template) {\n  var _template$getBounding = template.getBoundingClientRect(),\n      top = _template$getBounding.top,\n      left = _template$getBounding.left,\n      width = _template$getBounding.width,\n      height = _template$getBounding.height;\n\n  var clone = template.cloneNode();\n  var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n  var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;\n\n  clone.removeAttribute('id');\n  clone.style.position = 'absolute';\n  clone.style.top = top + scrollTop + 'px';\n  clone.style.left = left + scrollLeft + 'px';\n  clone.style.width = width + 'px';\n  clone.style.height = height + 'px';\n  clone.style.transform = '';\n\n  return clone;\n};\n\nvar createCustomEvent = function createCustomEvent(type, params) {\n  var eventParams = _extends({\n    bubbles: false,\n    cancelable: false,\n    detail: undefined\n  }, params);\n\n  if (typeof window.CustomEvent === 'function') {\n    return new CustomEvent(type, eventParams);\n  }\n\n  var customEvent = document.createEvent('CustomEvent');\n  customEvent.initCustomEvent(type, eventParams.bubbles, eventParams.cancelable, eventParams.detail);\n\n  return customEvent;\n};\n\nvar mediumZoom = function mediumZoom(selector) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /**\n   * Ensure the compatibility with IE11 if no Promise polyfill are used.\n   */\n  var Promise = window.Promise || function Promise(fn) {\n    function noop() {}\n    fn(noop, noop);\n  };\n\n  var _handleClick = function _handleClick(event) {\n    var target = event.target;\n\n\n    if (target === overlay) {\n      close();\n      return;\n    }\n\n    if (images.indexOf(target) === -1) {\n      return;\n    }\n\n    toggle({ target: target });\n  };\n\n  var _handleScroll = function _handleScroll() {\n    if (isAnimating || !active.original) {\n      return;\n    }\n\n    var currentScroll = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n\n    if (Math.abs(scrollTop - currentScroll) > zoomOptions.scrollOffset) {\n      setTimeout(close, 150);\n    }\n  };\n\n  var _handleKeyUp = function _handleKeyUp(event) {\n    var key = event.key || event.keyCode;\n\n    // Close if escape key is pressed\n    if (key === 'Escape' || key === 'Esc' || key === 27) {\n      close();\n    }\n  };\n\n  var update = function update() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var newOptions = options;\n\n    if (options.background) {\n      overlay.style.background = options.background;\n    }\n\n    if (options.container && options.container instanceof Object) {\n      newOptions.container = _extends({}, zoomOptions.container, options.container);\n    }\n\n    if (options.template) {\n      var template = isNode(options.template) ? options.template : document.querySelector(options.template);\n\n      newOptions.template = template;\n    }\n\n    zoomOptions = _extends({}, zoomOptions, newOptions);\n\n    images.forEach(function (image) {\n      image.dispatchEvent(createCustomEvent('medium-zoom:update', {\n        detail: { zoom: zoom }\n      }));\n    });\n\n    return zoom;\n  };\n\n  var clone = function clone() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return mediumZoom(_extends({}, zoomOptions, options));\n  };\n\n  var attach = function attach() {\n    for (var _len = arguments.length, selectors = Array(_len), _key = 0; _key < _len; _key++) {\n      selectors[_key] = arguments[_key];\n    }\n\n    var newImages = selectors.reduce(function (imagesAccumulator, currentSelector) {\n      return [].concat(imagesAccumulator, getImagesFromSelector(currentSelector));\n    }, []);\n\n    newImages.filter(function (newImage) {\n      return images.indexOf(newImage) === -1;\n    }).forEach(function (newImage) {\n      images.push(newImage);\n      newImage.classList.add('medium-zoom-image');\n    });\n\n    eventListeners.forEach(function (_ref) {\n      var type = _ref.type,\n          listener = _ref.listener,\n          options = _ref.options;\n\n      newImages.forEach(function (image) {\n        image.addEventListener(type, listener, options);\n      });\n    });\n\n    return zoom;\n  };\n\n  var detach = function detach() {\n    for (var _len2 = arguments.length, selectors = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      selectors[_key2] = arguments[_key2];\n    }\n\n    if (active.zoomed) {\n      close();\n    }\n\n    var imagesToDetach = selectors.length > 0 ? selectors.reduce(function (imagesAccumulator, currentSelector) {\n      return [].concat(imagesAccumulator, getImagesFromSelector(currentSelector));\n    }, []) : images;\n\n    imagesToDetach.forEach(function (image) {\n      image.classList.remove('medium-zoom-image');\n      image.dispatchEvent(createCustomEvent('medium-zoom:detach', {\n        detail: { zoom: zoom }\n      }));\n    });\n\n    images = images.filter(function (image) {\n      return imagesToDetach.indexOf(image) === -1;\n    });\n\n    return zoom;\n  };\n\n  var on = function on(type, listener) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    images.forEach(function (image) {\n      image.addEventListener('medium-zoom:' + type, listener, options);\n    });\n\n    eventListeners.push({ type: 'medium-zoom:' + type, listener: listener, options: options });\n\n    return zoom;\n  };\n\n  var off = function off(type, listener) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    images.forEach(function (image) {\n      image.removeEventListener('medium-zoom:' + type, listener, options);\n    });\n\n    eventListeners = eventListeners.filter(function (eventListener) {\n      return !(eventListener.type === 'medium-zoom:' + type && eventListener.listener.toString() === listener.toString());\n    });\n\n    return zoom;\n  };\n\n  var open = function open() {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        target = _ref2.target;\n\n    var _animate = function _animate() {\n      var container = {\n        width: document.documentElement.clientWidth,\n        height: document.documentElement.clientHeight,\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0\n      };\n      var viewportWidth = void 0;\n      var viewportHeight = void 0;\n\n      if (zoomOptions.container) {\n        if (zoomOptions.container instanceof Object) {\n          // The container is given as an object with properties like width, height, left, top\n          container = _extends({}, container, zoomOptions.container);\n\n          // We need to adjust custom options like container.right or container.bottom\n          viewportWidth = container.width - container.left - container.right - zoomOptions.margin * 2;\n          viewportHeight = container.height - container.top - container.bottom - zoomOptions.margin * 2;\n        } else {\n          // The container is given as an element\n          var zoomContainer = isNode(zoomOptions.container) ? zoomOptions.container : document.querySelector(zoomOptions.container);\n\n          var _zoomContainer$getBou = zoomContainer.getBoundingClientRect(),\n              _width = _zoomContainer$getBou.width,\n              _height = _zoomContainer$getBou.height,\n              _left = _zoomContainer$getBou.left,\n              _top = _zoomContainer$getBou.top;\n\n          container = _extends({}, container, {\n            width: _width,\n            height: _height,\n            left: _left,\n            top: _top\n          });\n        }\n      }\n\n      viewportWidth = viewportWidth || container.width - zoomOptions.margin * 2;\n      viewportHeight = viewportHeight || container.height - zoomOptions.margin * 2;\n\n      var zoomTarget = active.zoomedHd || active.original;\n      var naturalWidth = isSvg(zoomTarget) ? viewportWidth : zoomTarget.naturalWidth || viewportWidth;\n      var naturalHeight = isSvg(zoomTarget) ? viewportHeight : zoomTarget.naturalHeight || viewportHeight;\n\n      var _zoomTarget$getBoundi = zoomTarget.getBoundingClientRect(),\n          top = _zoomTarget$getBoundi.top,\n          left = _zoomTarget$getBoundi.left,\n          width = _zoomTarget$getBoundi.width,\n          height = _zoomTarget$getBoundi.height;\n\n      var scaleX = Math.min(Math.max(width, naturalWidth), viewportWidth) / width;\n      var scaleY = Math.min(Math.max(height, naturalHeight), viewportHeight) / height;\n      var scale = Math.min(scaleX, scaleY);\n      var translateX = (-left + (viewportWidth - width) / 2 + zoomOptions.margin + container.left) / scale;\n      var translateY = (-top + (viewportHeight - height) / 2 + zoomOptions.margin + container.top) / scale;\n      var transform = 'scale(' + scale + ') translate3d(' + translateX + 'px, ' + translateY + 'px, 0)';\n\n      active.zoomed.style.transform = transform;\n\n      if (active.zoomedHd) {\n        active.zoomedHd.style.transform = transform;\n      }\n    };\n\n    return new Promise(function (resolve) {\n      if (target && images.indexOf(target) === -1) {\n        resolve(zoom);\n        return;\n      }\n\n      var _handleOpenEnd = function _handleOpenEnd() {\n        isAnimating = false;\n        active.zoomed.removeEventListener('transitionend', _handleOpenEnd);\n        active.original.dispatchEvent(createCustomEvent('medium-zoom:opened', {\n          detail: { zoom: zoom }\n        }));\n\n        resolve(zoom);\n      };\n\n      if (active.zoomed) {\n        resolve(zoom);\n        return;\n      }\n\n      if (target) {\n        // The zoom was triggered manually via a click\n        active.original = target;\n      } else if (images.length > 0) {\nvar _images = images;\n        active.original = _images[0];\n      } else {\n        resolve(zoom);\n        return;\n      }\n\n      active.original.dispatchEvent(createCustomEvent('medium-zoom:open', {\n        detail: { zoom: zoom }\n      }));\n\n      scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n      isAnimating = true;\n      active.zoomed = cloneTarget(active.original);\n\n      document.body.appendChild(overlay);\n\n      if (zoomOptions.template) {\n        var template = isNode(zoomOptions.template) ? zoomOptions.template : document.querySelector(zoomOptions.template);\n        active.template = document.createElement('div');\n        active.template.appendChild(template.content.cloneNode(true));\n\n        document.body.appendChild(active.template);\n      }\n\n      // If the selected <img> tag is inside a <picture> tag, set the\n      // currently-applied source as the cloned `src=` attribute.\n      // (as these might differ, or src= might be unset in some cases)\n      if (active.original.parentElement && active.original.parentElement.tagName === 'PICTURE' && active.original.currentSrc) {\n        active.zoomed.src = active.original.currentSrc;\n      }\n\n      document.body.appendChild(active.zoomed);\n\n      window.requestAnimationFrame(function () {\n        document.body.classList.add('medium-zoom--opened');\n      });\n\n      active.original.classList.add('medium-zoom-image--hidden');\n      active.zoomed.classList.add('medium-zoom-image--opened');\n\n      active.zoomed.addEventListener('click', close);\n      active.zoomed.addEventListener('transitionend', _handleOpenEnd);\n\n      if (active.original.getAttribute('data-zoom-src')) {\n        active.zoomedHd = active.zoomed.cloneNode();\n\n        // Reset the `scrset` property or the HD image won't load.\n        active.zoomedHd.removeAttribute('srcset');\n        active.zoomedHd.removeAttribute('sizes');\n        // Remove loading attribute so the browser can load the image normally\n        active.zoomedHd.removeAttribute('loading');\n\n        active.zoomedHd.src = active.zoomed.getAttribute('data-zoom-src');\n\n        active.zoomedHd.onerror = function () {\n          clearInterval(getZoomTargetSize);\n          console.warn('Unable to reach the zoom image target ' + active.zoomedHd.src);\n          active.zoomedHd = null;\n          _animate();\n        };\n\n        // We need to access the natural size of the full HD\n        // target as fast as possible to compute the animation.\n        var getZoomTargetSize = setInterval(function () {\n          if ( active.zoomedHd.complete) {\n            clearInterval(getZoomTargetSize);\n            active.zoomedHd.classList.add('medium-zoom-image--opened');\n            active.zoomedHd.addEventListener('click', close);\n            document.body.appendChild(active.zoomedHd);\n            _animate();\n          }\n        }, 10);\n      } else if (active.original.hasAttribute('srcset')) {\n        // If an image has a `srcset` attribuet, we don't know the dimensions of the\n        // zoomed (HD) image (like when `data-zoom-src` is specified).\n        // Therefore the approach is quite similar.\n        active.zoomedHd = active.zoomed.cloneNode();\n\n        // Resetting the sizes attribute tells the browser to load the\n        // image best fitting the current viewport size, respecting the `srcset`.\n        active.zoomedHd.removeAttribute('sizes');\n\n        // In Firefox, the `loading` attribute needs to be set to `eager` (default\n        // value) for the load event to be fired.\n        active.zoomedHd.removeAttribute('loading');\n\n        // Wait for the load event of the hd image. This will fire if the image\n        // is already cached.\n        var loadEventListener = active.zoomedHd.addEventListener('load', function () {\n          active.zoomedHd.removeEventListener('load', loadEventListener);\n          active.zoomedHd.classList.add('medium-zoom-image--opened');\n          active.zoomedHd.addEventListener('click', close);\n          document.body.appendChild(active.zoomedHd);\n          _animate();\n        });\n      } else {\n        _animate();\n      }\n    });\n  };\n\n  var close = function close() {\n    return new Promise(function (resolve) {\n      if (isAnimating || !active.original) {\n        resolve(zoom);\n        return;\n      }\n\n      var _handleCloseEnd = function _handleCloseEnd() {\n        active.original.classList.remove('medium-zoom-image--hidden');\n        document.body.removeChild(active.zoomed);\n        if (active.zoomedHd) {\n          document.body.removeChild(active.zoomedHd);\n        }\n        document.body.removeChild(overlay);\n        active.zoomed.classList.remove('medium-zoom-image--opened');\n        if (active.template) {\n          document.body.removeChild(active.template);\n        }\n\n        isAnimating = false;\n        active.zoomed.removeEventListener('transitionend', _handleCloseEnd);\n\n        active.original.dispatchEvent(createCustomEvent('medium-zoom:closed', {\n          detail: { zoom: zoom }\n        }));\n\n        active.original = null;\n        active.zoomed = null;\n        active.zoomedHd = null;\n        active.template = null;\n\n        resolve(zoom);\n      };\n\n      isAnimating = true;\n      document.body.classList.remove('medium-zoom--opened');\n      active.zoomed.style.transform = '';\n\n      if (active.zoomedHd) {\n        active.zoomedHd.style.transform = '';\n      }\n\n      // Fade out the template so it's not too abrupt\n      if (active.template) {\n        active.template.style.transition = 'opacity 150ms';\n        active.template.style.opacity = 0;\n      }\n\n      active.original.dispatchEvent(createCustomEvent('medium-zoom:close', {\n        detail: { zoom: zoom }\n      }));\n\n      active.zoomed.addEventListener('transitionend', _handleCloseEnd);\n    });\n  };\n\n  var toggle = function toggle() {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        target = _ref3.target;\n\n    if (active.original) {\n      return close();\n    }\n\n    return open({ target: target });\n  };\n\n  var getOptions = function getOptions() {\n    return zoomOptions;\n  };\n\n  var getImages = function getImages() {\n    return images;\n  };\n\n  var getZoomedImage = function getZoomedImage() {\n    return active.original;\n  };\n\n  var images = [];\n  var eventListeners = [];\n  var isAnimating = false;\n  var scrollTop = 0;\n  var zoomOptions = options;\n  var active = {\n    original: null,\n    zoomed: null,\n    zoomedHd: null,\n    template: null\n\n    // If the selector is omitted, it's replaced by the options\n  };if (Object.prototype.toString.call(selector) === '[object Object]') {\n    zoomOptions = selector;\n  } else if (selector || typeof selector === 'string' // to process empty string as a selector\n  ) {\n      attach(selector);\n    }\n\n  // Apply the default option values\n  zoomOptions = _extends({\n    margin: 0,\n    background: '#fff',\n    scrollOffset: 40,\n    container: null,\n    template: null\n  }, zoomOptions);\n\n  var overlay = createOverlay(zoomOptions.background);\n\n  document.addEventListener('click', _handleClick);\n  document.addEventListener('keyup', _handleKeyUp);\n  document.addEventListener('scroll', _handleScroll);\n  window.addEventListener('resize', close);\n\n  var zoom = {\n    open: open,\n    close: close,\n    toggle: toggle,\n    update: update,\n    clone: clone,\n    attach: attach,\n    detach: detach,\n    on: on,\n    off: off,\n    getOptions: getOptions,\n    getImages: getImages,\n    getZoomedImage: getZoomedImage\n  };\n\n  return zoom;\n};\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}\";\nstyleInject(css);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mediumZoom);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaXVtLXpvb20vZGlzdC9tZWRpdW0tem9vbS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxnQkFBZ0I7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0EseUVBQXlFLGFBQWE7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFLGVBQWU7QUFDM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCwwQkFBMEIsbUVBQW1FOztBQUU3RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLHNGQUFzRjtBQUN0Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHNGQUFzRjtBQUN0Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsZUFBZSxNQUFNLFFBQVEsU0FBUyxPQUFPLFVBQVUsdUJBQXVCLG9CQUFvQiwwQ0FBMEMsZUFBZSxnQkFBZ0IsVUFBVSxtQkFBbUIsZUFBZSxlQUFlLDJEQUEyRCwyQkFBMkIsa0JBQWtCLDJCQUEyQixrQkFBa0IsZUFBZSxnQkFBZ0Isc0JBQXNCO0FBQ2hkOztBQUVBLGlFQUFlLFVBQVUsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3d3d19zaGFkbmNuLy4vbm9kZV9tb2R1bGVzL21lZGl1bS16b29tL2Rpc3QvbWVkaXVtLXpvb20uZXNtLmpzP2FmNTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG1lZGl1bS16b29tIDEuMS4wIHwgTUlUIExpY2Vuc2UgfCBodHRwczovL2dpdGh1Yi5jb20vZnJhbmNvaXNjaGFsaWZvdXIvbWVkaXVtLXpvb20gKi9cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdJTUcnO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xudmFyIGlzTm9kZUxpc3QgPSBmdW5jdGlvbiBpc05vZGVMaXN0KHNlbGVjdG9yKSB7XG4gIHJldHVybiBOb2RlTGlzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihzZWxlY3Rvcik7XG59O1xuXG52YXIgaXNOb2RlID0gZnVuY3Rpb24gaXNOb2RlKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciAmJiBzZWxlY3Rvci5ub2RlVHlwZSA9PT0gMTtcbn07XG5cbnZhciBpc1N2ZyA9IGZ1bmN0aW9uIGlzU3ZnKGltYWdlKSB7XG4gIHZhciBzb3VyY2UgPSBpbWFnZS5jdXJyZW50U3JjIHx8IGltYWdlLnNyYztcbiAgcmV0dXJuIHNvdXJjZS5zdWJzdHIoLTQpLnRvTG93ZXJDYXNlKCkgPT09ICcuc3ZnJztcbn07XG5cbnZhciBnZXRJbWFnZXNGcm9tU2VsZWN0b3IgPSBmdW5jdGlvbiBnZXRJbWFnZXNGcm9tU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgdHJ5IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiBzZWxlY3Rvci5maWx0ZXIoaXNTdXBwb3J0ZWQpO1xuICAgIH1cblxuICAgIGlmIChpc05vZGVMaXN0KHNlbGVjdG9yKSkge1xuICAgICAgLy8gRG8gbm90IHVzZSBzcHJlYWQgb3BlcmF0b3Igb3IgQXJyYXkuZnJvbSgpIGZvciBJRSBzdXBwb3J0XG4gICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChzZWxlY3RvcikuZmlsdGVyKGlzU3VwcG9ydGVkKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOb2RlKHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIFtzZWxlY3Rvcl0uZmlsdGVyKGlzU3VwcG9ydGVkKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gRG8gbm90IHVzZSBzcHJlYWQgb3BlcmF0b3Igb3IgQXJyYXkuZnJvbSgpIGZvciBJRSBzdXBwb3J0XG4gICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkuZmlsdGVyKGlzU3VwcG9ydGVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBwcm92aWRlZCBzZWxlY3RvciBpcyBpbnZhbGlkLlxcbicgKyAnRXhwZWN0cyBhIENTUyBzZWxlY3RvciwgYSBOb2RlIGVsZW1lbnQsIGEgTm9kZUxpc3Qgb3IgYW4gYXJyYXkuXFxuJyArICdTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mcmFuY29pc2NoYWxpZm91ci9tZWRpdW0tem9vbScpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlT3ZlcmxheSA9IGZ1bmN0aW9uIGNyZWF0ZU92ZXJsYXkoYmFja2dyb3VuZCkge1xuICB2YXIgb3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBvdmVybGF5LmNsYXNzTGlzdC5hZGQoJ21lZGl1bS16b29tLW92ZXJsYXknKTtcbiAgb3ZlcmxheS5zdHlsZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcblxuICByZXR1cm4gb3ZlcmxheTtcbn07XG5cbnZhciBjbG9uZVRhcmdldCA9IGZ1bmN0aW9uIGNsb25lVGFyZ2V0KHRlbXBsYXRlKSB7XG4gIHZhciBfdGVtcGxhdGUkZ2V0Qm91bmRpbmcgPSB0ZW1wbGF0ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHRvcCA9IF90ZW1wbGF0ZSRnZXRCb3VuZGluZy50b3AsXG4gICAgICBsZWZ0ID0gX3RlbXBsYXRlJGdldEJvdW5kaW5nLmxlZnQsXG4gICAgICB3aWR0aCA9IF90ZW1wbGF0ZSRnZXRCb3VuZGluZy53aWR0aCxcbiAgICAgIGhlaWdodCA9IF90ZW1wbGF0ZSRnZXRCb3VuZGluZy5oZWlnaHQ7XG5cbiAgdmFyIGNsb25lID0gdGVtcGxhdGUuY2xvbmVOb2RlKCk7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCB8fCAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHwgMDtcblxuICBjbG9uZS5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gIGNsb25lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgY2xvbmUuc3R5bGUudG9wID0gdG9wICsgc2Nyb2xsVG9wICsgJ3B4JztcbiAgY2xvbmUuc3R5bGUubGVmdCA9IGxlZnQgKyBzY3JvbGxMZWZ0ICsgJ3B4JztcbiAgY2xvbmUuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIGNsb25lLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIGNsb25lLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuXG4gIHJldHVybiBjbG9uZTtcbn07XG5cbnZhciBjcmVhdGVDdXN0b21FdmVudCA9IGZ1bmN0aW9uIGNyZWF0ZUN1c3RvbUV2ZW50KHR5cGUsIHBhcmFtcykge1xuICB2YXIgZXZlbnRQYXJhbXMgPSBfZXh0ZW5kcyh7XG4gICAgYnViYmxlczogZmFsc2UsXG4gICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgZGV0YWlsOiB1bmRlZmluZWRcbiAgfSwgcGFyYW1zKTtcblxuICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQodHlwZSwgZXZlbnRQYXJhbXMpO1xuICB9XG5cbiAgdmFyIGN1c3RvbUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gIGN1c3RvbUV2ZW50LmluaXRDdXN0b21FdmVudCh0eXBlLCBldmVudFBhcmFtcy5idWJibGVzLCBldmVudFBhcmFtcy5jYW5jZWxhYmxlLCBldmVudFBhcmFtcy5kZXRhaWwpO1xuXG4gIHJldHVybiBjdXN0b21FdmVudDtcbn07XG5cbnZhciBtZWRpdW1ab29tID0gZnVuY3Rpb24gbWVkaXVtWm9vbShzZWxlY3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgLyoqXG4gICAqIEVuc3VyZSB0aGUgY29tcGF0aWJpbGl0eSB3aXRoIElFMTEgaWYgbm8gUHJvbWlzZSBwb2x5ZmlsbCBhcmUgdXNlZC5cbiAgICovXG4gIHZhciBQcm9taXNlID0gd2luZG93LlByb21pc2UgfHwgZnVuY3Rpb24gUHJvbWlzZShmbikge1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIGZuKG5vb3AsIG5vb3ApO1xuICB9O1xuXG4gIHZhciBfaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBfaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG5cbiAgICBpZiAodGFyZ2V0ID09PSBvdmVybGF5KSB7XG4gICAgICBjbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbWFnZXMuaW5kZXhPZih0YXJnZXQpID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRvZ2dsZSh7IHRhcmdldDogdGFyZ2V0IH0pO1xuICB9O1xuXG4gIHZhciBfaGFuZGxlU2Nyb2xsID0gZnVuY3Rpb24gX2hhbmRsZVNjcm9sbCgpIHtcbiAgICBpZiAoaXNBbmltYXRpbmcgfHwgIWFjdGl2ZS5vcmlnaW5hbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50U2Nyb2xsID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgMDtcblxuICAgIGlmIChNYXRoLmFicyhzY3JvbGxUb3AgLSBjdXJyZW50U2Nyb2xsKSA+IHpvb21PcHRpb25zLnNjcm9sbE9mZnNldCkge1xuICAgICAgc2V0VGltZW91dChjbG9zZSwgMTUwKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIF9oYW5kbGVLZXlVcCA9IGZ1bmN0aW9uIF9oYW5kbGVLZXlVcChldmVudCkge1xuICAgIHZhciBrZXkgPSBldmVudC5rZXkgfHwgZXZlbnQua2V5Q29kZTtcblxuICAgIC8vIENsb3NlIGlmIGVzY2FwZSBrZXkgaXMgcHJlc3NlZFxuICAgIGlmIChrZXkgPT09ICdFc2NhcGUnIHx8IGtleSA9PT0gJ0VzYycgfHwga2V5ID09PSAyNykge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kKSB7XG4gICAgICBvdmVybGF5LnN0eWxlLmJhY2tncm91bmQgPSBvcHRpb25zLmJhY2tncm91bmQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY29udGFpbmVyICYmIG9wdGlvbnMuY29udGFpbmVyIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICBuZXdPcHRpb25zLmNvbnRhaW5lciA9IF9leHRlbmRzKHt9LCB6b29tT3B0aW9ucy5jb250YWluZXIsIG9wdGlvbnMuY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50ZW1wbGF0ZSkge1xuICAgICAgdmFyIHRlbXBsYXRlID0gaXNOb2RlKG9wdGlvbnMudGVtcGxhdGUpID8gb3B0aW9ucy50ZW1wbGF0ZSA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy50ZW1wbGF0ZSk7XG5cbiAgICAgIG5ld09wdGlvbnMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICB6b29tT3B0aW9ucyA9IF9leHRlbmRzKHt9LCB6b29tT3B0aW9ucywgbmV3T3B0aW9ucyk7XG5cbiAgICBpbWFnZXMuZm9yRWFjaChmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIGltYWdlLmRpc3BhdGNoRXZlbnQoY3JlYXRlQ3VzdG9tRXZlbnQoJ21lZGl1bS16b29tOnVwZGF0ZScsIHtcbiAgICAgICAgZGV0YWlsOiB7IHpvb206IHpvb20gfVxuICAgICAgfSkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHpvb207XG4gIH07XG5cbiAgdmFyIGNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHJldHVybiBtZWRpdW1ab29tKF9leHRlbmRzKHt9LCB6b29tT3B0aW9ucywgb3B0aW9ucykpO1xuICB9O1xuXG4gIHZhciBhdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNlbGVjdG9ycyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgc2VsZWN0b3JzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBuZXdJbWFnZXMgPSBzZWxlY3RvcnMucmVkdWNlKGZ1bmN0aW9uIChpbWFnZXNBY2N1bXVsYXRvciwgY3VycmVudFNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KGltYWdlc0FjY3VtdWxhdG9yLCBnZXRJbWFnZXNGcm9tU2VsZWN0b3IoY3VycmVudFNlbGVjdG9yKSk7XG4gICAgfSwgW10pO1xuXG4gICAgbmV3SW1hZ2VzLmZpbHRlcihmdW5jdGlvbiAobmV3SW1hZ2UpIHtcbiAgICAgIHJldHVybiBpbWFnZXMuaW5kZXhPZihuZXdJbWFnZSkgPT09IC0xO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKG5ld0ltYWdlKSB7XG4gICAgICBpbWFnZXMucHVzaChuZXdJbWFnZSk7XG4gICAgICBuZXdJbWFnZS5jbGFzc0xpc3QuYWRkKCdtZWRpdW0tem9vbS1pbWFnZScpO1xuICAgIH0pO1xuXG4gICAgZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgICAgbGlzdGVuZXIgPSBfcmVmLmxpc3RlbmVyLFxuICAgICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG5cbiAgICAgIG5ld0ltYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHpvb207XG4gIH07XG5cbiAgdmFyIGRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNlbGVjdG9ycyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBzZWxlY3RvcnNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZlLnpvb21lZCkge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VzVG9EZXRhY2ggPSBzZWxlY3RvcnMubGVuZ3RoID4gMCA/IHNlbGVjdG9ycy5yZWR1Y2UoZnVuY3Rpb24gKGltYWdlc0FjY3VtdWxhdG9yLCBjdXJyZW50U2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoaW1hZ2VzQWNjdW11bGF0b3IsIGdldEltYWdlc0Zyb21TZWxlY3RvcihjdXJyZW50U2VsZWN0b3IpKTtcbiAgICB9LCBbXSkgOiBpbWFnZXM7XG5cbiAgICBpbWFnZXNUb0RldGFjaC5mb3JFYWNoKGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgaW1hZ2UuY2xhc3NMaXN0LnJlbW92ZSgnbWVkaXVtLXpvb20taW1hZ2UnKTtcbiAgICAgIGltYWdlLmRpc3BhdGNoRXZlbnQoY3JlYXRlQ3VzdG9tRXZlbnQoJ21lZGl1bS16b29tOmRldGFjaCcsIHtcbiAgICAgICAgZGV0YWlsOiB7IHpvb206IHpvb20gfVxuICAgICAgfSkpO1xuICAgIH0pO1xuXG4gICAgaW1hZ2VzID0gaW1hZ2VzLmZpbHRlcihmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIHJldHVybiBpbWFnZXNUb0RldGFjaC5pbmRleE9mKGltYWdlKSA9PT0gLTE7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gem9vbTtcbiAgfTtcblxuICB2YXIgb24gPSBmdW5jdGlvbiBvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGltYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbWVkaXVtLXpvb206JyArIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICB9KTtcblxuICAgIGV2ZW50TGlzdGVuZXJzLnB1c2goeyB0eXBlOiAnbWVkaXVtLXpvb206JyArIHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciwgb3B0aW9uczogb3B0aW9ucyB9KTtcblxuICAgIHJldHVybiB6b29tO1xuICB9O1xuXG4gIHZhciBvZmYgPSBmdW5jdGlvbiBvZmYodHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBpbWFnZXMuZm9yRWFjaChmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lZGl1bS16b29tOicgKyB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgfSk7XG5cbiAgICBldmVudExpc3RlbmVycyA9IGV2ZW50TGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoZXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuICEoZXZlbnRMaXN0ZW5lci50eXBlID09PSAnbWVkaXVtLXpvb206JyArIHR5cGUgJiYgZXZlbnRMaXN0ZW5lci5saXN0ZW5lci50b1N0cmluZygpID09PSBsaXN0ZW5lci50b1N0cmluZygpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB6b29tO1xuICB9O1xuXG4gIHZhciBvcGVuID0gZnVuY3Rpb24gb3BlbigpIHtcbiAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICB0YXJnZXQgPSBfcmVmMi50YXJnZXQ7XG5cbiAgICB2YXIgX2FuaW1hdGUgPSBmdW5jdGlvbiBfYW5pbWF0ZSgpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSB7XG4gICAgICAgIHdpZHRoOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgIGhlaWdodDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwXG4gICAgICB9O1xuICAgICAgdmFyIHZpZXdwb3J0V2lkdGggPSB2b2lkIDA7XG4gICAgICB2YXIgdmlld3BvcnRIZWlnaHQgPSB2b2lkIDA7XG5cbiAgICAgIGlmICh6b29tT3B0aW9ucy5jb250YWluZXIpIHtcbiAgICAgICAgaWYgKHpvb21PcHRpb25zLmNvbnRhaW5lciBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIC8vIFRoZSBjb250YWluZXIgaXMgZ2l2ZW4gYXMgYW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyBsaWtlIHdpZHRoLCBoZWlnaHQsIGxlZnQsIHRvcFxuICAgICAgICAgIGNvbnRhaW5lciA9IF9leHRlbmRzKHt9LCBjb250YWluZXIsIHpvb21PcHRpb25zLmNvbnRhaW5lcik7XG5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGFkanVzdCBjdXN0b20gb3B0aW9ucyBsaWtlIGNvbnRhaW5lci5yaWdodCBvciBjb250YWluZXIuYm90dG9tXG4gICAgICAgICAgdmlld3BvcnRXaWR0aCA9IGNvbnRhaW5lci53aWR0aCAtIGNvbnRhaW5lci5sZWZ0IC0gY29udGFpbmVyLnJpZ2h0IC0gem9vbU9wdGlvbnMubWFyZ2luICogMjtcbiAgICAgICAgICB2aWV3cG9ydEhlaWdodCA9IGNvbnRhaW5lci5oZWlnaHQgLSBjb250YWluZXIudG9wIC0gY29udGFpbmVyLmJvdHRvbSAtIHpvb21PcHRpb25zLm1hcmdpbiAqIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlIGNvbnRhaW5lciBpcyBnaXZlbiBhcyBhbiBlbGVtZW50XG4gICAgICAgICAgdmFyIHpvb21Db250YWluZXIgPSBpc05vZGUoem9vbU9wdGlvbnMuY29udGFpbmVyKSA/IHpvb21PcHRpb25zLmNvbnRhaW5lciA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioem9vbU9wdGlvbnMuY29udGFpbmVyKTtcblxuICAgICAgICAgIHZhciBfem9vbUNvbnRhaW5lciRnZXRCb3UgPSB6b29tQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICBfd2lkdGggPSBfem9vbUNvbnRhaW5lciRnZXRCb3Uud2lkdGgsXG4gICAgICAgICAgICAgIF9oZWlnaHQgPSBfem9vbUNvbnRhaW5lciRnZXRCb3UuaGVpZ2h0LFxuICAgICAgICAgICAgICBfbGVmdCA9IF96b29tQ29udGFpbmVyJGdldEJvdS5sZWZ0LFxuICAgICAgICAgICAgICBfdG9wID0gX3pvb21Db250YWluZXIkZ2V0Qm91LnRvcDtcblxuICAgICAgICAgIGNvbnRhaW5lciA9IF9leHRlbmRzKHt9LCBjb250YWluZXIsIHtcbiAgICAgICAgICAgIHdpZHRoOiBfd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IF9oZWlnaHQsXG4gICAgICAgICAgICBsZWZ0OiBfbGVmdCxcbiAgICAgICAgICAgIHRvcDogX3RvcFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydFdpZHRoIHx8IGNvbnRhaW5lci53aWR0aCAtIHpvb21PcHRpb25zLm1hcmdpbiAqIDI7XG4gICAgICB2aWV3cG9ydEhlaWdodCA9IHZpZXdwb3J0SGVpZ2h0IHx8IGNvbnRhaW5lci5oZWlnaHQgLSB6b29tT3B0aW9ucy5tYXJnaW4gKiAyO1xuXG4gICAgICB2YXIgem9vbVRhcmdldCA9IGFjdGl2ZS56b29tZWRIZCB8fCBhY3RpdmUub3JpZ2luYWw7XG4gICAgICB2YXIgbmF0dXJhbFdpZHRoID0gaXNTdmcoem9vbVRhcmdldCkgPyB2aWV3cG9ydFdpZHRoIDogem9vbVRhcmdldC5uYXR1cmFsV2lkdGggfHwgdmlld3BvcnRXaWR0aDtcbiAgICAgIHZhciBuYXR1cmFsSGVpZ2h0ID0gaXNTdmcoem9vbVRhcmdldCkgPyB2aWV3cG9ydEhlaWdodCA6IHpvb21UYXJnZXQubmF0dXJhbEhlaWdodCB8fCB2aWV3cG9ydEhlaWdodDtcblxuICAgICAgdmFyIF96b29tVGFyZ2V0JGdldEJvdW5kaSA9IHpvb21UYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgdG9wID0gX3pvb21UYXJnZXQkZ2V0Qm91bmRpLnRvcCxcbiAgICAgICAgICBsZWZ0ID0gX3pvb21UYXJnZXQkZ2V0Qm91bmRpLmxlZnQsXG4gICAgICAgICAgd2lkdGggPSBfem9vbVRhcmdldCRnZXRCb3VuZGkud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX3pvb21UYXJnZXQkZ2V0Qm91bmRpLmhlaWdodDtcblxuICAgICAgdmFyIHNjYWxlWCA9IE1hdGgubWluKE1hdGgubWF4KHdpZHRoLCBuYXR1cmFsV2lkdGgpLCB2aWV3cG9ydFdpZHRoKSAvIHdpZHRoO1xuICAgICAgdmFyIHNjYWxlWSA9IE1hdGgubWluKE1hdGgubWF4KGhlaWdodCwgbmF0dXJhbEhlaWdodCksIHZpZXdwb3J0SGVpZ2h0KSAvIGhlaWdodDtcbiAgICAgIHZhciBzY2FsZSA9IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgIHZhciB0cmFuc2xhdGVYID0gKC1sZWZ0ICsgKHZpZXdwb3J0V2lkdGggLSB3aWR0aCkgLyAyICsgem9vbU9wdGlvbnMubWFyZ2luICsgY29udGFpbmVyLmxlZnQpIC8gc2NhbGU7XG4gICAgICB2YXIgdHJhbnNsYXRlWSA9ICgtdG9wICsgKHZpZXdwb3J0SGVpZ2h0IC0gaGVpZ2h0KSAvIDIgKyB6b29tT3B0aW9ucy5tYXJnaW4gKyBjb250YWluZXIudG9wKSAvIHNjYWxlO1xuICAgICAgdmFyIHRyYW5zZm9ybSA9ICdzY2FsZSgnICsgc2NhbGUgKyAnKSB0cmFuc2xhdGUzZCgnICsgdHJhbnNsYXRlWCArICdweCwgJyArIHRyYW5zbGF0ZVkgKyAncHgsIDApJztcblxuICAgICAgYWN0aXZlLnpvb21lZC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cbiAgICAgIGlmIChhY3RpdmUuem9vbWVkSGQpIHtcbiAgICAgICAgYWN0aXZlLnpvb21lZEhkLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBpZiAodGFyZ2V0ICYmIGltYWdlcy5pbmRleE9mKHRhcmdldCkgPT09IC0xKSB7XG4gICAgICAgIHJlc29sdmUoem9vbSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9oYW5kbGVPcGVuRW5kID0gZnVuY3Rpb24gX2hhbmRsZU9wZW5FbmQoKSB7XG4gICAgICAgIGlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIGFjdGl2ZS56b29tZWQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIF9oYW5kbGVPcGVuRW5kKTtcbiAgICAgICAgYWN0aXZlLm9yaWdpbmFsLmRpc3BhdGNoRXZlbnQoY3JlYXRlQ3VzdG9tRXZlbnQoJ21lZGl1bS16b29tOm9wZW5lZCcsIHtcbiAgICAgICAgICBkZXRhaWw6IHsgem9vbTogem9vbSB9XG4gICAgICAgIH0pKTtcblxuICAgICAgICByZXNvbHZlKHpvb20pO1xuICAgICAgfTtcblxuICAgICAgaWYgKGFjdGl2ZS56b29tZWQpIHtcbiAgICAgICAgcmVzb2x2ZSh6b29tKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIC8vIFRoZSB6b29tIHdhcyB0cmlnZ2VyZWQgbWFudWFsbHkgdmlhIGEgY2xpY2tcbiAgICAgICAgYWN0aXZlLm9yaWdpbmFsID0gdGFyZ2V0O1xuICAgICAgfSBlbHNlIGlmIChpbWFnZXMubGVuZ3RoID4gMCkge1xudmFyIF9pbWFnZXMgPSBpbWFnZXM7XG4gICAgICAgIGFjdGl2ZS5vcmlnaW5hbCA9IF9pbWFnZXNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKHpvb20pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFjdGl2ZS5vcmlnaW5hbC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUN1c3RvbUV2ZW50KCdtZWRpdW0tem9vbTpvcGVuJywge1xuICAgICAgICBkZXRhaWw6IHsgem9vbTogem9vbSB9XG4gICAgICB9KSk7XG5cbiAgICAgIHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICBpc0FuaW1hdGluZyA9IHRydWU7XG4gICAgICBhY3RpdmUuem9vbWVkID0gY2xvbmVUYXJnZXQoYWN0aXZlLm9yaWdpbmFsKTtcblxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5KTtcblxuICAgICAgaWYgKHpvb21PcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGlzTm9kZSh6b29tT3B0aW9ucy50ZW1wbGF0ZSkgPyB6b29tT3B0aW9ucy50ZW1wbGF0ZSA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioem9vbU9wdGlvbnMudGVtcGxhdGUpO1xuICAgICAgICBhY3RpdmUudGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYWN0aXZlLnRlbXBsYXRlLmFwcGVuZENoaWxkKHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGFjdGl2ZS50ZW1wbGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBzZWxlY3RlZCA8aW1nPiB0YWcgaXMgaW5zaWRlIGEgPHBpY3R1cmU+IHRhZywgc2V0IHRoZVxuICAgICAgLy8gY3VycmVudGx5LWFwcGxpZWQgc291cmNlIGFzIHRoZSBjbG9uZWQgYHNyYz1gIGF0dHJpYnV0ZS5cbiAgICAgIC8vIChhcyB0aGVzZSBtaWdodCBkaWZmZXIsIG9yIHNyYz0gbWlnaHQgYmUgdW5zZXQgaW4gc29tZSBjYXNlcylcbiAgICAgIGlmIChhY3RpdmUub3JpZ2luYWwucGFyZW50RWxlbWVudCAmJiBhY3RpdmUub3JpZ2luYWwucGFyZW50RWxlbWVudC50YWdOYW1lID09PSAnUElDVFVSRScgJiYgYWN0aXZlLm9yaWdpbmFsLmN1cnJlbnRTcmMpIHtcbiAgICAgICAgYWN0aXZlLnpvb21lZC5zcmMgPSBhY3RpdmUub3JpZ2luYWwuY3VycmVudFNyYztcbiAgICAgIH1cblxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhY3RpdmUuem9vbWVkKTtcblxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnbWVkaXVtLXpvb20tLW9wZW5lZCcpO1xuICAgICAgfSk7XG5cbiAgICAgIGFjdGl2ZS5vcmlnaW5hbC5jbGFzc0xpc3QuYWRkKCdtZWRpdW0tem9vbS1pbWFnZS0taGlkZGVuJyk7XG4gICAgICBhY3RpdmUuem9vbWVkLmNsYXNzTGlzdC5hZGQoJ21lZGl1bS16b29tLWltYWdlLS1vcGVuZWQnKTtcblxuICAgICAgYWN0aXZlLnpvb21lZC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsb3NlKTtcbiAgICAgIGFjdGl2ZS56b29tZWQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIF9oYW5kbGVPcGVuRW5kKTtcblxuICAgICAgaWYgKGFjdGl2ZS5vcmlnaW5hbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtem9vbS1zcmMnKSkge1xuICAgICAgICBhY3RpdmUuem9vbWVkSGQgPSBhY3RpdmUuem9vbWVkLmNsb25lTm9kZSgpO1xuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBgc2Nyc2V0YCBwcm9wZXJ0eSBvciB0aGUgSEQgaW1hZ2Ugd29uJ3QgbG9hZC5cbiAgICAgICAgYWN0aXZlLnpvb21lZEhkLnJlbW92ZUF0dHJpYnV0ZSgnc3Jjc2V0Jyk7XG4gICAgICAgIGFjdGl2ZS56b29tZWRIZC5yZW1vdmVBdHRyaWJ1dGUoJ3NpemVzJyk7XG4gICAgICAgIC8vIFJlbW92ZSBsb2FkaW5nIGF0dHJpYnV0ZSBzbyB0aGUgYnJvd3NlciBjYW4gbG9hZCB0aGUgaW1hZ2Ugbm9ybWFsbHlcbiAgICAgICAgYWN0aXZlLnpvb21lZEhkLnJlbW92ZUF0dHJpYnV0ZSgnbG9hZGluZycpO1xuXG4gICAgICAgIGFjdGl2ZS56b29tZWRIZC5zcmMgPSBhY3RpdmUuem9vbWVkLmdldEF0dHJpYnV0ZSgnZGF0YS16b29tLXNyYycpO1xuXG4gICAgICAgIGFjdGl2ZS56b29tZWRIZC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZ2V0Wm9vbVRhcmdldFNpemUpO1xuICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIHJlYWNoIHRoZSB6b29tIGltYWdlIHRhcmdldCAnICsgYWN0aXZlLnpvb21lZEhkLnNyYyk7XG4gICAgICAgICAgYWN0aXZlLnpvb21lZEhkID0gbnVsbDtcbiAgICAgICAgICBfYW5pbWF0ZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gYWNjZXNzIHRoZSBuYXR1cmFsIHNpemUgb2YgdGhlIGZ1bGwgSERcbiAgICAgICAgLy8gdGFyZ2V0IGFzIGZhc3QgYXMgcG9zc2libGUgdG8gY29tcHV0ZSB0aGUgYW5pbWF0aW9uLlxuICAgICAgICB2YXIgZ2V0Wm9vbVRhcmdldFNpemUgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCBhY3RpdmUuem9vbWVkSGQuY29tcGxldGUpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZ2V0Wm9vbVRhcmdldFNpemUpO1xuICAgICAgICAgICAgYWN0aXZlLnpvb21lZEhkLmNsYXNzTGlzdC5hZGQoJ21lZGl1bS16b29tLWltYWdlLS1vcGVuZWQnKTtcbiAgICAgICAgICAgIGFjdGl2ZS56b29tZWRIZC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsb3NlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYWN0aXZlLnpvb21lZEhkKTtcbiAgICAgICAgICAgIF9hbmltYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxMCk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2ZS5vcmlnaW5hbC5oYXNBdHRyaWJ1dGUoJ3NyY3NldCcpKSB7XG4gICAgICAgIC8vIElmIGFuIGltYWdlIGhhcyBhIGBzcmNzZXRgIGF0dHJpYnVldCwgd2UgZG9uJ3Qga25vdyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcbiAgICAgICAgLy8gem9vbWVkIChIRCkgaW1hZ2UgKGxpa2Ugd2hlbiBgZGF0YS16b29tLXNyY2AgaXMgc3BlY2lmaWVkKS5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHRoZSBhcHByb2FjaCBpcyBxdWl0ZSBzaW1pbGFyLlxuICAgICAgICBhY3RpdmUuem9vbWVkSGQgPSBhY3RpdmUuem9vbWVkLmNsb25lTm9kZSgpO1xuXG4gICAgICAgIC8vIFJlc2V0dGluZyB0aGUgc2l6ZXMgYXR0cmlidXRlIHRlbGxzIHRoZSBicm93c2VyIHRvIGxvYWQgdGhlXG4gICAgICAgIC8vIGltYWdlIGJlc3QgZml0dGluZyB0aGUgY3VycmVudCB2aWV3cG9ydCBzaXplLCByZXNwZWN0aW5nIHRoZSBgc3Jjc2V0YC5cbiAgICAgICAgYWN0aXZlLnpvb21lZEhkLnJlbW92ZUF0dHJpYnV0ZSgnc2l6ZXMnKTtcblxuICAgICAgICAvLyBJbiBGaXJlZm94LCB0aGUgYGxvYWRpbmdgIGF0dHJpYnV0ZSBuZWVkcyB0byBiZSBzZXQgdG8gYGVhZ2VyYCAoZGVmYXVsdFxuICAgICAgICAvLyB2YWx1ZSkgZm9yIHRoZSBsb2FkIGV2ZW50IHRvIGJlIGZpcmVkLlxuICAgICAgICBhY3RpdmUuem9vbWVkSGQucmVtb3ZlQXR0cmlidXRlKCdsb2FkaW5nJyk7XG5cbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIGxvYWQgZXZlbnQgb2YgdGhlIGhkIGltYWdlLiBUaGlzIHdpbGwgZmlyZSBpZiB0aGUgaW1hZ2VcbiAgICAgICAgLy8gaXMgYWxyZWFkeSBjYWNoZWQuXG4gICAgICAgIHZhciBsb2FkRXZlbnRMaXN0ZW5lciA9IGFjdGl2ZS56b29tZWRIZC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGFjdGl2ZS56b29tZWRIZC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZEV2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgIGFjdGl2ZS56b29tZWRIZC5jbGFzc0xpc3QuYWRkKCdtZWRpdW0tem9vbS1pbWFnZS0tb3BlbmVkJyk7XG4gICAgICAgICAgYWN0aXZlLnpvb21lZEhkLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xvc2UpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYWN0aXZlLnpvb21lZEhkKTtcbiAgICAgICAgICBfYW5pbWF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hbmltYXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBpZiAoaXNBbmltYXRpbmcgfHwgIWFjdGl2ZS5vcmlnaW5hbCkge1xuICAgICAgICByZXNvbHZlKHpvb20pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfaGFuZGxlQ2xvc2VFbmQgPSBmdW5jdGlvbiBfaGFuZGxlQ2xvc2VFbmQoKSB7XG4gICAgICAgIGFjdGl2ZS5vcmlnaW5hbC5jbGFzc0xpc3QucmVtb3ZlKCdtZWRpdW0tem9vbS1pbWFnZS0taGlkZGVuJyk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYWN0aXZlLnpvb21lZCk7XG4gICAgICAgIGlmIChhY3RpdmUuem9vbWVkSGQpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGFjdGl2ZS56b29tZWRIZCk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdmVybGF5KTtcbiAgICAgICAgYWN0aXZlLnpvb21lZC5jbGFzc0xpc3QucmVtb3ZlKCdtZWRpdW0tem9vbS1pbWFnZS0tb3BlbmVkJyk7XG4gICAgICAgIGlmIChhY3RpdmUudGVtcGxhdGUpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGFjdGl2ZS50ZW1wbGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICBhY3RpdmUuem9vbWVkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBfaGFuZGxlQ2xvc2VFbmQpO1xuXG4gICAgICAgIGFjdGl2ZS5vcmlnaW5hbC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUN1c3RvbUV2ZW50KCdtZWRpdW0tem9vbTpjbG9zZWQnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7IHpvb206IHpvb20gfVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgYWN0aXZlLm9yaWdpbmFsID0gbnVsbDtcbiAgICAgICAgYWN0aXZlLnpvb21lZCA9IG51bGw7XG4gICAgICAgIGFjdGl2ZS56b29tZWRIZCA9IG51bGw7XG4gICAgICAgIGFjdGl2ZS50ZW1wbGF0ZSA9IG51bGw7XG5cbiAgICAgICAgcmVzb2x2ZSh6b29tKTtcbiAgICAgIH07XG5cbiAgICAgIGlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnbWVkaXVtLXpvb20tLW9wZW5lZCcpO1xuICAgICAgYWN0aXZlLnpvb21lZC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcblxuICAgICAgaWYgKGFjdGl2ZS56b29tZWRIZCkge1xuICAgICAgICBhY3RpdmUuem9vbWVkSGQuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgICB9XG5cbiAgICAgIC8vIEZhZGUgb3V0IHRoZSB0ZW1wbGF0ZSBzbyBpdCdzIG5vdCB0b28gYWJydXB0XG4gICAgICBpZiAoYWN0aXZlLnRlbXBsYXRlKSB7XG4gICAgICAgIGFjdGl2ZS50ZW1wbGF0ZS5zdHlsZS50cmFuc2l0aW9uID0gJ29wYWNpdHkgMTUwbXMnO1xuICAgICAgICBhY3RpdmUudGVtcGxhdGUuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGFjdGl2ZS5vcmlnaW5hbC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUN1c3RvbUV2ZW50KCdtZWRpdW0tem9vbTpjbG9zZScsIHtcbiAgICAgICAgZGV0YWlsOiB7IHpvb206IHpvb20gfVxuICAgICAgfSkpO1xuXG4gICAgICBhY3RpdmUuem9vbWVkLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBfaGFuZGxlQ2xvc2VFbmQpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciB0b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgdGFyZ2V0ID0gX3JlZjMudGFyZ2V0O1xuXG4gICAgaWYgKGFjdGl2ZS5vcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wZW4oeyB0YXJnZXQ6IHRhcmdldCB9KTtcbiAgfTtcblxuICB2YXIgZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHpvb21PcHRpb25zO1xuICB9O1xuXG4gIHZhciBnZXRJbWFnZXMgPSBmdW5jdGlvbiBnZXRJbWFnZXMoKSB7XG4gICAgcmV0dXJuIGltYWdlcztcbiAgfTtcblxuICB2YXIgZ2V0Wm9vbWVkSW1hZ2UgPSBmdW5jdGlvbiBnZXRab29tZWRJbWFnZSgpIHtcbiAgICByZXR1cm4gYWN0aXZlLm9yaWdpbmFsO1xuICB9O1xuXG4gIHZhciBpbWFnZXMgPSBbXTtcbiAgdmFyIGV2ZW50TGlzdGVuZXJzID0gW107XG4gIHZhciBpc0FuaW1hdGluZyA9IGZhbHNlO1xuICB2YXIgc2Nyb2xsVG9wID0gMDtcbiAgdmFyIHpvb21PcHRpb25zID0gb3B0aW9ucztcbiAgdmFyIGFjdGl2ZSA9IHtcbiAgICBvcmlnaW5hbDogbnVsbCxcbiAgICB6b29tZWQ6IG51bGwsXG4gICAgem9vbWVkSGQ6IG51bGwsXG4gICAgdGVtcGxhdGU6IG51bGxcblxuICAgIC8vIElmIHRoZSBzZWxlY3RvciBpcyBvbWl0dGVkLCBpdCdzIHJlcGxhY2VkIGJ5IHRoZSBvcHRpb25zXG4gIH07aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzZWxlY3RvcikgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgem9vbU9wdGlvbnMgPSBzZWxlY3RvcjtcbiAgfSBlbHNlIGlmIChzZWxlY3RvciB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnIC8vIHRvIHByb2Nlc3MgZW1wdHkgc3RyaW5nIGFzIGEgc2VsZWN0b3JcbiAgKSB7XG4gICAgICBhdHRhY2goc2VsZWN0b3IpO1xuICAgIH1cblxuICAvLyBBcHBseSB0aGUgZGVmYXVsdCBvcHRpb24gdmFsdWVzXG4gIHpvb21PcHRpb25zID0gX2V4dGVuZHMoe1xuICAgIG1hcmdpbjogMCxcbiAgICBiYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgc2Nyb2xsT2Zmc2V0OiA0MCxcbiAgICBjb250YWluZXI6IG51bGwsXG4gICAgdGVtcGxhdGU6IG51bGxcbiAgfSwgem9vbU9wdGlvbnMpO1xuXG4gIHZhciBvdmVybGF5ID0gY3JlYXRlT3ZlcmxheSh6b29tT3B0aW9ucy5iYWNrZ3JvdW5kKTtcblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF9oYW5kbGVDbGljayk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgX2hhbmRsZUtleVVwKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX2hhbmRsZVNjcm9sbCk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBjbG9zZSk7XG5cbiAgdmFyIHpvb20gPSB7XG4gICAgb3Blbjogb3BlbixcbiAgICBjbG9zZTogY2xvc2UsXG4gICAgdG9nZ2xlOiB0b2dnbGUsXG4gICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgY2xvbmU6IGNsb25lLFxuICAgIGF0dGFjaDogYXR0YWNoLFxuICAgIGRldGFjaDogZGV0YWNoLFxuICAgIG9uOiBvbixcbiAgICBvZmY6IG9mZixcbiAgICBnZXRPcHRpb25zOiBnZXRPcHRpb25zLFxuICAgIGdldEltYWdlczogZ2V0SW1hZ2VzLFxuICAgIGdldFpvb21lZEltYWdlOiBnZXRab29tZWRJbWFnZVxuICB9O1xuXG4gIHJldHVybiB6b29tO1xufTtcblxuZnVuY3Rpb24gc3R5bGVJbmplY3QoY3NzLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICB2YXIgaW5zZXJ0QXQgPSByZWYuaW5zZXJ0QXQ7XG5cbiAgaWYgKCFjc3MgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm47IH1cblxuICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cbiAgaWYgKGluc2VydEF0ID09PSAndG9wJykge1xuICAgIGlmIChoZWFkLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgY3NzID0gXCIubWVkaXVtLXpvb20tb3ZlcmxheXtwb3NpdGlvbjpmaXhlZDt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IC4zczt3aWxsLWNoYW5nZTpvcGFjaXR5fS5tZWRpdW0tem9vbS0tb3BlbmVkIC5tZWRpdW0tem9vbS1vdmVybGF5e2N1cnNvcjpwb2ludGVyO2N1cnNvcjp6b29tLW91dDtvcGFjaXR5OjF9Lm1lZGl1bS16b29tLWltYWdle2N1cnNvcjpwb2ludGVyO2N1cnNvcjp6b29tLWluO3RyYW5zaXRpb246dHJhbnNmb3JtIC4zcyBjdWJpYy1iZXppZXIoLjIsMCwuMiwxKSFpbXBvcnRhbnR9Lm1lZGl1bS16b29tLWltYWdlLS1oaWRkZW57dmlzaWJpbGl0eTpoaWRkZW59Lm1lZGl1bS16b29tLWltYWdlLS1vcGVuZWR7cG9zaXRpb246cmVsYXRpdmU7Y3Vyc29yOnBvaW50ZXI7Y3Vyc29yOnpvb20tb3V0O3dpbGwtY2hhbmdlOnRyYW5zZm9ybX1cIjtcbnN0eWxlSW5qZWN0KGNzcyk7XG5cbmV4cG9ydCBkZWZhdWx0IG1lZGl1bVpvb207XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/medium-zoom/dist/medium-zoom.esm.js\n");

/***/ })

};
;